var EventEmitter=require("events").EventEmitter;var util=require("util");var debug=require("debug")("engine:socket");module.exports=Socket;function Socket(d,b,c,a){this.id=d;this.server=b;this.upgrading=false;this.upgraded=false;this.readyState="opening";this.writeBuffer=[];this.packetsFn=[];this.sentCallbackFn=[];this.cleanupFn=[];this.request=a;this.remoteAddress=a.connection.remoteAddress;this.checkIntervalTimer=null;this.upgradeTimeoutTimer=null;this.pingTimeoutTimer=null;this.setTransport(c);this.onOpen()}util.inherits(Socket,EventEmitter);Socket.prototype.onOpen=function(){this.readyState="open";this.transport.sid=this.id;this.sendPacket("open",JSON.stringify({sid:this.id,upgrades:this.getAvailableUpgrades(),pingInterval:this.server.pingInterval,pingTimeout:this.server.pingTimeout}));if(this.server.initialPacket){this.sendPacket("message",this.server.initialPacket)}this.emit("open");this.setPingTimeout()};Socket.prototype.onPacket=function(a){if("open"===this.readyState){debug("packet");this.emit("packet",a);this.setPingTimeout();switch(a.type){case"ping":debug("got ping");this.sendPacket("pong");this.emit("heartbeat");break;case"error":this.onClose("parse error");break;case"message":this.emit("data",a.data);this.emit("message",a.data);break}}else{debug("packet received with closed socket")}};Socket.prototype.onError=function(a){debug("transport error");this.onClose("transport error",a)};Socket.prototype.setPingTimeout=function(){var a=this;clearTimeout(a.pingTimeoutTimer);a.pingTimeoutTimer=setTimeout(function(){a.onClose("ping timeout")},a.server.pingInterval+a.server.pingTimeout)};Socket.prototype.setTransport=function(e){var d=this.onError.bind(this);var b=this.onPacket.bind(this);var a=this.flush.bind(this);var c=this.onClose.bind(this,"transport close");this.transport=e;this.transport.once("error",d);this.transport.on("packet",b);this.transport.on("drain",a);this.transport.once("close",c);this.setupSendCallback();this.cleanupFn.push(function(){e.removeListener("error",d);e.removeListener("packet",b);e.removeListener("drain",a);e.removeListener("close",c)})};Socket.prototype.maybeUpgrade=function(h){debug('might upgrade socket transport from "%s" to "%s"',this.transport.name,h.name);this.upgrading=true;var e=this;e.upgradeTimeoutTimer=setTimeout(function(){debug("client did not complete upgrade - closing transport");f();if("open"===h.readyState){h.close()}},this.server.upgradeTimeout);function b(i){if("ping"===i.type&&"probe"===i.data){h.send([{type:"pong",data:"probe"}]);e.emit("upgrading",h);clearInterval(e.checkIntervalTimer);e.checkIntervalTimer=setInterval(d,100)}else{if("upgrade"===i.type&&e.readyState!=="closed"){debug("got upgrade packet - upgrading");f();e.transport.discard();e.upgraded=true;e.clearTransport();e.setTransport(h);e.emit("upgrade",h);e.setPingTimeout();e.flush();if(e.readyState==="closing"){h.close(function(){e.onClose("forced close")})}}else{f();h.close()}}}function d(){if("polling"===e.transport.name&&e.transport.writable){debug("writing a noop packet to polling for fast upgrade");e.transport.send([{type:"noop"}])}}function f(){e.upgrading=false;clearInterval(e.checkIntervalTimer);e.checkIntervalTimer=null;clearTimeout(e.upgradeTimeoutTimer);e.upgradeTimeoutTimer=null;h.removeListener("packet",b);h.removeListener("close",a);h.removeListener("error",g);e.removeListener("close",c)}function g(i){debug("client did not complete upgrade - %s",i);f();h.close();h=null}function a(){g("transport closed")}function c(){g("socket closed")}h.on("packet",b);h.once("close",a);h.once("error",g);e.once("close",c)};Socket.prototype.clearTransport=function(){var c;var b=this.cleanupFn.length;for(var a=0;a<b;a++){c=this.cleanupFn.shift();c()}this.transport.on("error",function(){debug("error triggered by discarded transport")});this.transport.close();clearTimeout(this.pingTimeoutTimer)};Socket.prototype.onClose=function(c,b){if("closed"!==this.readyState){this.readyState="closed";clearTimeout(this.pingTimeoutTimer);clearInterval(this.checkIntervalTimer);this.checkIntervalTimer=null;clearTimeout(this.upgradeTimeoutTimer);var a=this;process.nextTick(function(){a.writeBuffer=[]});this.packetsFn=[];this.sentCallbackFn=[];this.clearTransport();this.emit("close",c,b)}};Socket.prototype.setupSendCallback=function(){var a=this;this.transport.on("drain",b);this.cleanupFn.push(function(){a.transport.removeListener("drain",b)});function b(){if(a.sentCallbackFn.length>0){var e=a.sentCallbackFn.splice(0,1)[0];if("function"===typeof e){debug("executing send callback");e(a.transport)}else{if(Array.isArray(e)){debug("executing batch send callback");for(var c=e.length,d=0;d<c;d++){if("function"===typeof e[d]){e[d](a.transport)}}}}}}};Socket.prototype.send=Socket.prototype.write=function(b,a,c){this.sendPacket("message",b,a,c);return this};Socket.prototype.sendPacket=function(b,c,a,e){if("function"===typeof a){e=a;a=null}a=a||{};a.compress=false!==a.compress;if("closing"!==this.readyState&&"closed"!==this.readyState){debug('sending packet "%s" (%s)',b,c);var d={type:b,options:a};if(c){d.data=c}this.emit("packetCreate",d);this.writeBuffer.push(d);if(e){this.packetsFn.push(e)}this.flush()}};Socket.prototype.flush=function(){if("closed"!==this.readyState&&this.transport.writable&&this.writeBuffer.length){debug("flushing buffer to transport");this.emit("flush",this.writeBuffer);this.server.emit("flush",this,this.writeBuffer);var a=this.writeBuffer;this.writeBuffer=[];if(!this.transport.supportsFraming){this.sentCallbackFn.push(this.packetsFn)}else{this.sentCallbackFn.push.apply(this.sentCallbackFn,this.packetsFn)}this.packetsFn=[];this.transport.send(a);this.emit("drain");this.server.emit("drain",this)}};Socket.prototype.getAvailableUpgrades=function(){var b=[];var e=this.server.upgrades(this.transport.name);for(var d=0,a=e.length;d<a;++d){var c=e[d];if(this.server.transports.indexOf(c)!==-1){b.push(c)}}return b};Socket.prototype.close=function(a){if("open"!==this.readyState){return}this.readyState="closing";if(this.writeBuffer.length){this.once("drain",this.closeTransport.bind(this,a));return}this.closeTransport(a)};Socket.prototype.closeTransport=function(a){if(a){this.transport.discard()}this.transport.close(this.onClose.bind(this,"forced close"))};